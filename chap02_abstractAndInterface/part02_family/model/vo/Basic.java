package com.kh.chap02_abstractAndInterface.part02_family.model.vo;

// 인터페이스
public interface Basic {

	/*
	 * * 인터페이스
	 * 모든 필드가 "상수필드" 이고, 모든 메소드가 "추상메소드" 인 일종의
	 * 추상클래스
	 * 
	 * [ 표현법 ]
	 * 접근제한자 interface 인터페이스명 {
	 * 			// 필드부 - 상수필드(static final)
	 * 			// 메소드부 - 추상메소드 (abstract)
	 * 
	 * }
	 * 
	 * > 인터페이스에서 모든 필드는 무조건 상수필드
	 * > 인터페이스에서 모든 메소드는 무조건 추상메소드
	 * > 무조건 구현해야하는게 있을 때 인터페이스를 만들어서 상속하게 된다.
	 * > 추상클래스와 다르게 좀 더 강한 규칙성, 강제성을 띄는 게 인터페이스!!
	 * 
	 * > 인터페이스는 다중상속이 허용된다!!
	 * 		모든 필드가 상수필드이기 때문에 클래스명.필드명으로 접근해서
	 * 	필드명이 중복되더라도 상관 없기 때문
	 * 	모든 메소드가 추상메소드이기 때문에 결국 최종 구현은
	 *  자식클래스에서 이루어지기 때문
	 * 	
	 * 		extends 와 implements
	 * 		- 클래스 간의 상속 관계일 때 (단일상속)
	 * 		자식클래스명 extends 부모클래스명
	 * 		- 클래스와 인터페이스 사이의 상속(구현) 관계일 때
	 * 		  자식클래스명 implements 인터페이스명
	 * 		- 인터페이스 간의 상속 관계일 때 (다중상속)
	 * 		  자식인터페이스명 extends 부모인터페이스명, 부모인터페이스명,...
	 * 
	 * * 추상클래스와 인터페이스
	 * 1. 공통점
	 * - 객체 생성은 안되나, 참조변수로써 사용이 가능하다.
	 * 		(즉, 다형성을 적용할 수 있다.)
	 * - 상속받는 클래스에 추상메소드를 구현하도록 (오버라이딩 하도록) 강제한다.
	 * 
	 * 2. 차이점
	 * - 추상클래스는 클래스 내에 인스턴스 변수, 일반메소드를 작성 가능하고
	 *   추상메소드가 포함되었거나 abstract 키워드로 클래스가 정의됨
	 *   인터페이스는 모든 필드는 상수필드, 메소드는 추상메소드로 정의됨
	 * - 존재하는 목적이 다르다.
	 * 	 추상클래스는 상속받아서 기능을 이용하고, 
	 * 	 내가 필요한 코드를 덧붙여서 클래스를 확장 (extends) 하는 목적
	 *   인터페이스는 상속받아서 기능의 내용을
	 *   단순히 구현 (implements) (채워넣겠다) 하는 목적
	 *   (구현, 동작을 강제하기 위해서 쓴다.
	 *    구현을 강제함으로써 구현 객체의 같은 동작을 보장할 수 있다.)
	 *    
	 *    인터페이스 == 일종의 추상클래스
	 * 	 
	 */
	
	// 필드부 - 모두 상수필드
	/*public static final*/ int num = 10;
	// > 인터페이스에는 상수필드만 정의할 수 있기 때문에
	// public static final 이 생략 가능하다.(암묵적, 묵시적 표현법)
	// 메소드부 - 모두 추상메소드
	
	/*public abstract*/ void eat();
	 void sleep();
	// > 인터페이스에는 추상메소드만 정의할 수 있기 때문에
	 // public abstract 가 생략 가능하다. (암묵적, 묵시적 표현법)
	 
	
	
	
	
	
}
